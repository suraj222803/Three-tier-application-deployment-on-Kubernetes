# Three-Tier Application Deployment on Kubernetes (EKS)

**what do you mean by three tier ?**


Itâ€™s actually a division of your system in 3 parts

1. **Presentation Layer (Tier 1):**
   
- What you you see when you open your website is called the presentation layer basically it is the layer that users interact directly


2. **Logical Layer (Tier 2):**

Imagine this layer as the brain behind the scenes. It takes the information you provide through the user interface and processes it according to the rules of the system. If itâ€™s a shopping website, for instance, this layer figures out things like the total price of your items, applies discounts, and checks if everything is in stock
<br>
3. **Data Layer (Tier 3):**

- This is where the data is stored and retrieved. Itâ€™s like the memory of the system.
- Data could be stored in databases, files, or any other data storage systems.
- The data layer is responsible for managing and storing information that the system needs.

<img width="431" height="223" alt="image" src="https://github.com/user-attachments/assets/44a5089e-6cae-40f8-8df4-f736c1a7c002" />

---

## Completion Steps â†’

 **Phase 1** â†’ Setup base EC2 , IAM user and Basic tools on EC2

**Phase 2** â†’ Built frontend and backend images

**Phase 3** â†’ Kubernetes

**Phase 4** â†’Setup Application Load balancer and ingress

**Phase 5** â†’Destroy Everything


---

## ğŸ“ Project Structure

```text
.
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ source code
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ source code
â”œâ”€â”€ k8s_manifests/
â”‚   â”œâ”€â”€ frontend-deployment.yaml
â”‚   â”œâ”€â”€ frontend-service.yaml
â”‚   â”œâ”€â”€ backend-deployment.yaml
â”‚   â”œâ”€â”€ backend-service.yaml
â”‚   â”œâ”€â”€ full_stack_lb.yaml
â”‚   â””â”€â”€ mongo/
â”‚       â”œâ”€â”€ mongo-deployment.yaml
â”‚       â””â”€â”€ mongo-service.yaml
â””â”€â”€ README.md
```
---
## Phase 1 â†’Setup base EC2 , IAM user and Basic tools on EC2

**Step 1. Create an IAM user**
<br>  <br>
<img width="700" height="389" alt="image" src="https://github.com/user-attachments/assets/06b20ba6-a877-4ca8-b4f2-c688c9458d2f" />


1. Click on IAM

<br> <br>
2. Click on user --> Creaate User

<img width="256" height="364" alt="image" src="https://github.com/user-attachments/assets/caea2f89-ad37-4ac3-b184-633e6f6be3a6" />

<br> <br>

3. Give a name to your user and tick on provide user access to management console and then click on I want an IAM user option

<img width="720" height="405" alt="image" src="https://github.com/user-attachments/assets/3ab9998d-0f2b-4eca-9de7-b37671cdd2b8" />

<br> <br>

4. choose a password for your user â†’click next


<br> <br>
5. Attach the policies directly to your iam user â†’ click next

<br> <br>
**Note --> I will provide the administrator accesss for now but we careful while attaching the policies at your workapce**
<br>
<br>


<img width="700" height="394" alt="image" src="https://github.com/user-attachments/assets/9e7aee69-66cd-462f-a792-783612c4142f" />

<img width="700" height="394" alt="image" src="https://github.com/user-attachments/assets/040a4829-395f-47b0-8332-e7bb55d1375d" />

<br><br>

review and create user

<br><br>

6. click on create user
<br><br>
<img width="700" height="394" alt="image" src="https://github.com/user-attachments/assets/d69e32b1-b581-427e-8c8f-b915c313cff9" />

<br><br>
7. download your password file if it is autogenerated otherwise it is yourâ€™s choice

<br><br>
<img width="720" height="166" alt="image" src="https://github.com/user-attachments/assets/01188ef2-4916-4b02-9971-886577947442" />

<br><br>

8. Now click on your IAM user â†’security credentials

<br><br>
<img width="700" height="80" alt="image" src="https://github.com/user-attachments/assets/0feb7d3b-5feb-4aa9-893e-efb91fe6949b" />

<br><br>
9. scroll down to access keys and create an access keys

<br><br>
<img width="700" height="271" alt="image" src="https://github.com/user-attachments/assets/f9e6a699-4daf-4c31-94ea-a34d3777c76c" />

<br><br>
10. choose aws cli from the options listed

<br><br>
<img width="700" height="394" alt="image" src="https://github.com/user-attachments/assets/7fe77186-a2a3-4c68-ba67-12c014ca4710" />
<br>

11. click next and download you csv file for username and password
<br>

<img width="700" height="394" alt="image" src="https://github.com/user-attachments/assets/e84d05c7-a983-4d4f-b031-29b7adca2789" />

<br><br>

**Step 2. launching a base EC2 where we do all work**
<br>
1. open your aws console and navigate to ec2 and click on launch ec2
<img width="720" height="405" alt="image" src="https://github.com/user-attachments/assets/beadc97b-df17-446e-9e04-874e23d21e11" />
<br>
2. Click on connect and run the following commands
```text
sudo su
apt update
mkdir 3-tier
cd 3-tier
```

3. fetch the code from github by git clone
   ```text
   https://github.com/suraj222803/Three-tier-application-deployment-on-Kubernetes.git

   ```
4. Run ls to see the what is inside the repo
   ```text
   ls
   ```
<img width="720" height="37" alt="image" src="https://github.com/user-attachments/assets/9fd1e7d2-3efc-41b1-94bd-ebc44b8cad37" />

**Step 3 --> Setup aws cli ,docker ,kubectl and eksctl**

**1. configuring aws cli**

AWS CLI (Amazon Web Services Command Line Interface) is a tool that allows you to interact with AWS services using commands

1. run the following commands to install aws cli
```text
snap install aws-cli --classic
```
2.   you have to configure aws by the command â†’
```text
aws configure
```   
3. It is asked for access key and secret key now you have to open that csv file you downloaded above and copy the access and secret key.
<img width="696" height="143" alt="image" src="https://github.com/user-attachments/assets/2e2c49f7-39db-4bcd-ac60-89526f173b89" />

4. Remain everything as it is and click enter.
   
   *your aws cli is setup now setup docker*

**2. Setup docker**
1. run the following commands
```text
apt install docker.io
usermod -aG docker $USER # Replace with your username e.g â€˜ubuntuâ€™
newgrp docker
sudo chmod 777 /var/run/docker.sock
which docker
```
<img width="1100" height="619" alt="image" src="https://github.com/user-attachments/assets/05028cf1-a321-4725-bee5-ba4bf10427fc" />

<img width="560" height="50" alt="image" src="https://github.com/user-attachments/assets/1f9885cd-ecf9-4c88-aaca-b71be94f2352" />

**3. setup kubectl**

*It is a command-line tool used in managing and interacting with Kubernetes clusters*

1. To install kubectl run the following commands
```text
snap install kubectl --classic
```
<img width="720" height="97" alt="image" src="https://github.com/user-attachments/assets/69dc2dfb-ab83-4792-8d48-f78a11e61107" />

**4. setup eksctl**

*It is a command-line tool used for managing Amazon EKS (Elastic Kubernetes Service) clusters.*

1. To install eksctl tool run the following commands
```text
curl --silent --location "https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz" | tar xz -C /tmp
sudo mv /tmp/eksctl /usr/local/bin
eksctl version
```
<img width="720" height="50" alt="image" src="https://github.com/user-attachments/assets/16b393d1-7221-4632-84bd-ae9d81dff4a7" />

##Phase 2 â†’Built frontend and backend images

**Step 1 â†’ setup Elastic container registery (ECR)**

*It is similiar to dockerhub where we stored the docker images*

1. Go to your aws console and search for ECR.
2. *click on create repository* for frontend and set visiblity setting to public
<img width="720" height="197" alt="image" src="https://github.com/user-attachments/assets/7a07e6eb-865b-4e1b-953f-10ed3f5dfe60" />
<img width="720" height="405" alt="image" src="https://github.com/user-attachments/assets/5bfe307d-65fe-4666-b869-da81b7f55b36" />

3. Setup backend Repository
<img width="720" height="486" alt="image" src="https://github.com/user-attachments/assets/5df6bb00-8912-4857-afcf-0ca78a79d594" />
<img width="720" height="280" alt="image" src="https://github.com/user-attachments/assets/0a3e9470-22ee-4880-837b-e8adf937a978" />

**Step 2 --> Setup frontend**

1. In terminal go to frontend directory and run ls command
```text
cd forntend/
ls
```
<img width="720" height="95" alt="image" src="https://github.com/user-attachments/assets/87c55249-23b2-485e-8437-b187c0e2af3a" />

2. Go to your ecr repo and click on view push commands
<img width="720" height="405" alt="image" src="https://github.com/user-attachments/assets/3d949bfc-de14-478d-979c-976bc8b61dc2" />

3.  Run the above command one by one to build the frontend image and push to ecr repository
```text
aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws/l0l7e4u1
docker build -t 3-tier-frontend .
docker tag 3-tier-frontend:latest public.ecr.aws/l0l7e4u1/3-tier-frontend:latest
docker push public.ecr.aws/l0l7e4u1/3-tier-frontend:latest
```
<img width="720" height="405" alt="image" src="https://github.com/user-attachments/assets/828e7505-ee79-48e9-8d9a-ac1fc5e0663c" />
<img width="720" height="161" alt="image" src="https://github.com/user-attachments/assets/0f22f064-793c-45b4-8f6a-b451506b5766" />

4. Letâ€™s run a container from the image
```text
docker images -->copy the image name from the list 
docker run -d -p 3000:3000 3-tier-frontend:latest
```
<img width="720" height="52" alt="image" src="https://github.com/user-attachments/assets/a7127b9d-71b5-4fc8-a645-10df21fb37b7" />

*your frontend has setup and your application is now running to see your application you could browse â†’public-ip:3000*
<img width="720" height="405" alt="image" src="https://github.com/user-attachments/assets/cc3aa1b6-45bc-438b-921e-468327b941cb" />

**Step 3 â†’Setup backend**
<img width="720" height="95" alt="image" src="https://github.com/user-attachments/assets/53697884-9a8b-4728-aa5a-651d3f2668a2" />

1. Now go to backend directory to setup backend
```text
cd ../backend
ls
```
<img width="720" height="41" alt="image" src="https://github.com/user-attachments/assets/4fe43521-d47d-46c8-984a-eb7ae9be2597" />

2. Go to your ecr repo and click on view push commands of backend repo.
<img width="720" height="405" alt="image" src="https://github.com/user-attachments/assets/d008501f-5aca-407b-bb0e-1af14e7f6819" />

3. run the above command one by one in your terminal
```text
aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws/l0l7e4u1
docker build -t 3-tier-backend .
docker tag 3-tier-backend:latest public.ecr.aws/l0l7e4u1/3-tier-backend:latest
docker push public.ecr.aws/l0l7e4u1/3-tier-backend:latest
```
<img width="720" height="405" alt="image" src="https://github.com/user-attachments/assets/bfd14bf4-dc02-4538-a0af-70c3cd38a77e" />
<img width="720" height="405" alt="image" src="https://github.com/user-attachments/assets/f2d30ce6-f0ec-491b-af45-d53dc34588b6" />

*Now your backend imge is built successfully and also pushed to Elastic container registery which we used when we create elastic kubernetes service*

## Phase 3 --> Kubernetes

**1. What is Deployment:**
-  *Imagine a Factory:* Think of a deployment as a factory that produces and manages copies of your software applications.

-  *Multiple Replicas:* Just like a factory can produce multiple identical items, a deployment in Kubernetes can create and handle multiple copies (replicas) of your application.

-  *Easy Updates:* If you want to change or update your application, the deployment system can smoothly handle that, like swapping out parts in a factory without stopping production.
-  
**2. what is Service:**
- *Imagine a Reception Desk:*  Picture a service in Kubernetes like a reception desk in a building.

- *Central Point of Contact:* The service provides a central point of contact for your applications. Instead of trying to find each application directly, other parts of your system can talk to the service, and it knows how to find the right application.
  
- *Stable Address:* Just as you have a consistent address for the reception desk, a service has a stable address that other parts of your system can use to communicate with your applications.

**3. What is Namesapce**

- Itâ€™s like a labeled section within Kubernetes where you can organize and run your applications. Each namespace is like a fenced-off area where your apps can do their thing without stepping on each otherâ€™s toes.

- So, in simpler terms, a namespace in Kubernetes is a way to keep different projects or applications separate and organized, making it easier to manage them in the bustling environment of a Kubernetes cluster


**Step 1 --> Setup EKS Cluster and create a namespace**

1. Run the following command to setup EKS cluster
```text
eksctl create cluster --name three-tier-cluster --region us-east-1 --node-type t2.medium --nodes-min 2 --nodes-max 2
aws eks update-kubeconfig --region us-east-1 --name three-tier-cluster
kubectl get nodes
``` 
2. It takes 15 to 20 mins to create a cluster
<img width="720" height="405" alt="image" src="https://github.com/user-attachments/assets/b556c5e9-26dc-4062-994e-605890e57567" />


3. on aws console search for aws cloud formation to view the events happening in creation of EKS cluster
<img width="720" height="405" alt="image" src="https://github.com/user-attachments/assets/57a53b1e-60d2-40af-b287-d6ead9bdaf58" />
<img width="720" height="62" alt="image" src="https://github.com/user-attachments/assets/2046a30d-4654-49ae-bac0-8987ca671091" />

4. creating Namesapce from the following command
```text
kubectl create namespace workshop
kubectl config set-context --current --namespace workshop
```
<img width="720" height="49" alt="image" src="https://github.com/user-attachments/assets/5629bb66-de2f-491e-8b4d-b24f7aa4af7d" />

**Step 2--> create a deployment and service for Frontend**
1. go to k8s_manifests directory there you will find deployment and service files for frontend
```text
cd ../k8s_manifests
```
<img width="373" height="398" alt="image" src="https://github.com/user-attachments/assets/5c5f61bd-616e-482c-8b21-28a69a282c2e" />

2. you have to edit the file called frontend-deployment.yaml

3. one thing you need to be changed that is your image name
<img width="720" height="117" alt="image" src="https://github.com/user-attachments/assets/63bacfe1-8ae2-47e9-90c0-a672038c18f4" />


4. so, go to your ecr repo --> select the frontend repo --> click on view public listing and copy the image name and paste inside the frontend-deployment.yaml file 

Now run the following commands to create the deployment and service for frontend

```text
kubectl apply -f frontend-deployment.yaml
kubectl apply -f frontend-service.yaml
```

**Step 3â†’ create a deployment and service for Backend**

1. In the same folder you will find backend-deployment.yaml and backend-service.yaml

2. you have to edit the file called backend-deployment.yaml

3. one thing you need to be changed that is your image name

4. so, go to your ecr repo â†’ select the backend repo â†’click on view public listing and copy the image name and paste inside the backend-deployment.yaml file

   
Now run the following commands to create the deployment and service backend

```text
kubectl apply -f backend-deployment.yaml
kubectl apply -f backend-service.yaml
kubectl get pods -n workshop
```
**Now our two tier is ready that is frontend and backend letâ€™s setup the third tier**

**step 4 â†’Setup Database tier**

1. Locate the mongo folder that stores deployment , service and secrets manifests

2. Run the below commands to setup database tier

```text
kubectl apply -f .
kubectl get all
```
<img width="720" height="241" alt="image" src="https://github.com/user-attachments/assets/104cc5ad-85bf-4825-898f-efbd4bc41a34" />

Now your all three tiers are ready to go but how do you access them for that we have to create a application load balancer to route outside traffic towards cluster and an ingress for in internal routing between our 3 tiers

##Phase 4 --> Setup Application Load balancer and ingress

*we have to create a application load balancer to route outside traffic towards cluster and an ingress for in internal routing between our 3 tiers*

**Step 1 --> Setup aws load balancer ; installation and attachement it to your EKS cluster**

1. Below command fetch the iam policy for your ALB
```text
curl -O https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.5.4/docs/install/iam_policy.json
```
<img width="720" height="47" alt="image" src="https://github.com/user-attachments/assets/d2a61cbb-908a-4f0f-99e1-6c4369bf3c61" />

2. This command create the iam policy in your aws account from iam_policy.json file that is setup in the first command

```text
aws iam create-policy --policy-name AWSLoadBalancerControllerIAMPolicy --policy-document file://iam_policy.json
```
<img width="720" height="150" alt="image" src="https://github.com/user-attachments/assets/c349637c-921d-4141-9bdb-aa8841b9e6ed" />

3. This command apply the load balancer policy to your eks cluster so that your eks cluster is working with your load balancer according to the policy

```text
eksctl utils associate-iam-oidc-provider --region=us-east-1 --cluster=three-tier-cluster --approve
```
<img width="1100" height="55" alt="image" src="https://github.com/user-attachments/assets/33405979-d243-47d9-962c-5abbe6e86f90" />

4. This command create and attach an service account to your cluster so that your cluster is allowed to work with load balancer service

```text
eksctl create iamserviceaccount --cluster=three-tier-cluster --namespace=kube-system --name=aws-load-balancer-controller --role-name AmazonEKSLoadBalancerControllerRole --attach-policy arn=arn:aws:iam::767397866747:policy/AWSLoadBalancerControllerIAMPolicy --approve --region=us-east-1
```
*Note :- please change your aws account no. from the below command otherwise it wonâ€™t work*
<img width="1100" height="229" alt="image" src="https://github.com/user-attachments/assets/53ce4423-8a18-4d14-87c3-52163a491b04" />

*All the policies are attached letâ€™s deploy the load balancer*

5. For this we have to install helmâ†’Helm is a special tool that helps you easily carry and manage your software when youâ€™re using Kubernetes, which is like a big playground for running applications.

```text
sudo snap install helm --classic
```

6. After this we have to add a particular manifest for load balancer that is pre written by someone on eks repo by using helm

```text
helm repo add eks https://aws.github.io/eks-charts
```

7. update the eks repo using helm

```text
helm repo update eks
```
8. Install the load balancer controller on your eks cluster

```text
helm install aws-load-balancer-controller eks/aws-load-balancer-controller -n kube-system --set clusterName=my-cluster --set serviceAccount.create=false --set serviceAccount.name=aws-load-balancer-controller
kubectl get deployment -n kube-system aws-load-balancer-controller
```
<img width="720" height="223" alt="image" src="https://github.com/user-attachments/assets/05f7459f-7678-4090-b2d9-85e5a365bcb9" />

*Now your Load balancer is working letâ€™s setup Ingress for internal routing*

**Step 2 --> Setup Ingress for internal routing**
<img width="373" height="398" alt="image" src="https://github.com/user-attachments/assets/65276d33-a71b-44ed-b5b1-a6e144fc253b" />

1. Loacte the full_stack_lb.yaml file

```text
kubectl apply -f full_stack_lb.yaml
kubectl get ing -n workshop
```
2. go to your Web Browser and paste the above dns address
<img width="720" height="405" alt="image" src="https://github.com/user-attachments/assets/52114c0f-d1f9-4617-8a00-7d394f3e35e6" />

*Congrtas !! Your application is accessible through load balancer ingress*

##Phase 5 --> Destroy Everything

1. On your current folder run
```text
kubectl delete -f .
```
2. go to mongo folder to delete database tier
```text
kubectl delete -f .
```
3. Delete the cluster and the stack of your cloud formation
```text
eksctl delete cluster --name three-tier-cluster --region us-east-1
aws cloudformation delete-stack --stack-name eksctl-three-tier-cluster-cluster
```
4. you could checkout alll the changes in cloud formation console of aws
<img width="720" height="405" alt="image" src="https://github.com/user-attachments/assets/75e58461-ce6e-49d0-be43-c5f187dc5c9b" />


**Everything is deleted now thanks me for reducing your aws bill**

**Follow me on LinkedIn:**  
ğŸ”— [Suraj Ugale](https://www.linkedin.com/in/suraj-ugale/)










